/*******************************************************************************
 * Filename:  tcm_qla2xxx_fabric.c
 *
 * This file contains TCM_QLA2XXX functions for struct target_core_fabrib_ops
 * for Qlogic 2xxx series target mode HBAs
 *
 * Copyright (c) 2010 Rising Tide Systems, Inc
 * Copyright (c) 2010 Linux-iSCSI.org
 *
 * Copyright (c) 2010 Nicholas A. Bellinger <nab@linux-iscsi.org>
 *
 * tcm_qla2xxx_parse_wwn() and tcm_qla2xxx_format_wwn() contains code from
 * the TCM_FC / Open-FCoE.org fabric module.
 *
 * Copyright (c) 2010 Cisco Systems, Inc
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 ****************************************************************************/

#define TCM_QLA2XXX_FABRIC_C

#include <linux/slab.h>
#include <linux/kthread.h>
#include <linux/types.h>
#include <linux/list.h>
#include <linux/types.h>
#include <linux/string.h>
#include <linux/ctype.h>
#include <asm/unaligned.h>
#include <scsi/scsi.h>
#include <scsi/scsi_host.h>
#include <scsi/scsi_device.h>
#include <scsi/scsi_cmnd.h>
#include <scsi/libfc.h>

#include <target/target_core_base.h>
#include <target/target_core_transport.h>
#include <target/target_core_fabric_ops.h>
#include <target/target_core_fabric_lib.h>
#include <target/target_core_device.h>
#include <target/target_core_tpg.h>
#include <target/target_core_configfs.h>
#include <target/target_core_alua.h>

#include <tcm_qla2xxx_base.h>
#include <tcm_qla2xxx_fabric.h>

#undef TCM_QLA2XXX_FABRIC_C

int tcm_qla2xxx_check_true(se_portal_group_t *se_tpg)
{
	return 1;
}

int tcm_qla2xxx_check_false(se_portal_group_t *se_tpg)
{
	return 0;
}

/*
 * Parse WWN.
 * If strict, we require lower-case hex and colon separators to be sure
 * the name is the same as what would be generated by ft_format_wwn()
 * so the name and wwn are mapped one-to-one.
 */
ssize_t tcm_qla2xxx_parse_wwn(const char *name, u64 *wwn, int strict)
{
	const char *cp;
	char c;
	u32 nibble;
	u32 byte = 0;
	u32 pos = 0;
	u32 err;

	*wwn = 0;
	for (cp = name; cp < &name[TCM_QLA2XXX_NAMELEN - 1]; cp++) {
		c = *cp;
		if (c == '\n' && cp[1] == '\0')
			continue;
		if (strict && pos++ == 2 && byte++ < 7) {
			pos = 0;
			if (c == ':')
				continue;
			err = 1;
			goto fail;
		}
		if (c == '\0') {
			err = 2;
			if (strict && byte != 8)
				goto fail;
			return cp - name;
		}
		err = 3;
		if (isdigit(c))
			nibble = c - '0';
		else if (isxdigit(c) && (islower(c) || !strict))
			nibble = tolower(c) - 'a' + 10;
		else
			goto fail;
		*wwn = (*wwn << 4) | nibble;
	}
	err = 4;
fail:
	printk(KERN_INFO "err %u len %zu pos %u byte %u\n",
			err, cp - name, pos, byte);
	return -1;
}

ssize_t tcm_qla2xxx_format_wwn(char *buf, size_t len, u64 wwn)
{
	u8 b[8];

	put_unaligned_be64(wwn, b);
	return snprintf(buf, len,
		"%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x",
		b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7]);
}

char *tcm_qla2xxx_get_fabric_name(void)
{
	return "lpfc";
}

u8 tcm_qla2xxx_get_fabric_proto_ident(se_portal_group_t *se_tpg)
{
	struct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,
				struct tcm_qla2xxx_tpg, se_tpg);
	struct tcm_qla2xxx_lport *lport = tpg->lport;
	u8 proto_id;

	switch (lport->lport_proto_id) {
	case SCSI_PROTOCOL_FCP:
	default:
		proto_id = fc_get_fabric_proto_ident(se_tpg);
		break;
	}

	return proto_id;
}

char *tcm_qla2xxx_get_fabric_wwn(se_portal_group_t *se_tpg)
{
	struct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,
				struct tcm_qla2xxx_tpg, se_tpg);
	struct tcm_qla2xxx_lport *lport = tpg->lport;

	return &lport->lport_name[0];
}

u16 tcm_qla2xxx_get_tag(se_portal_group_t *se_tpg)
{
	struct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,
				struct tcm_qla2xxx_tpg, se_tpg);
	return tpg->lport_tpgt;
}

u32 tcm_qla2xxx_get_default_depth(se_portal_group_t *se_tpg)
{
	return 1;
}

u32 tcm_qla2xxx_get_pr_transport_id(
	se_portal_group_t *se_tpg,
	se_node_acl_t *se_nacl,
	t10_pr_registration_t *pr_reg,
	int *format_code,
	unsigned char *buf)
{
	struct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,
				struct tcm_qla2xxx_tpg, se_tpg);
	struct tcm_qla2xxx_lport *lport = tpg->lport;
	int ret = 0;

	switch (lport->lport_proto_id) {
	case SCSI_PROTOCOL_FCP:
	default:
		ret = fc_get_pr_transport_id(se_tpg, se_nacl, pr_reg,
					format_code, buf);
		break;
	}

	return ret;
}		

u32 tcm_qla2xxx_get_pr_transport_id_len(
	se_portal_group_t *se_tpg,
	se_node_acl_t *se_nacl,
	t10_pr_registration_t *pr_reg,
	int *format_code)
{
	struct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,
				struct tcm_qla2xxx_tpg, se_tpg);
	struct tcm_qla2xxx_lport *lport = tpg->lport;
	int ret = 0;

	switch (lport->lport_proto_id) {
	case SCSI_PROTOCOL_FCP:
	default:
		ret = fc_get_pr_transport_id_len(se_tpg, se_nacl, pr_reg,
					format_code);
		break;
	}

	return ret;
}

char *tcm_qla2xxx_parse_pr_out_transport_id(
	se_portal_group_t *se_tpg,
	const char *buf,
	u32 *out_tid_len,
	char **port_nexus_ptr)
{
	struct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,
				struct tcm_qla2xxx_tpg, se_tpg);
	struct tcm_qla2xxx_lport *lport = tpg->lport;
	char *tid = NULL;

	switch (lport->lport_proto_id) {
	case SCSI_PROTOCOL_FCP:
	default:
		tid = fc_parse_pr_out_transport_id(se_tpg, buf, out_tid_len,
					port_nexus_ptr);
		break;
	}

	return tid;
}

se_node_acl_t *tcm_qla2xxx_alloc_fabric_acl(se_portal_group_t *se_tpg)
{
	struct tcm_qla2xxx_nacl *nacl;

	nacl = kzalloc(sizeof(struct tcm_qla2xxx_nacl), GFP_KERNEL);
	if (!(nacl)) {
		printk(KERN_ERR "Unable to alocate struct tcm_qla2xxx_nacl\n");
		return NULL;
	}

	return &nacl->se_node_acl;
}

void tcm_qla2xxx_release_fabric_acl(
	se_portal_group_t *se_tpg,
	se_node_acl_t *se_nacl)
{
	struct tcm_qla2xxx_nacl *nacl = container_of(se_nacl,
			struct tcm_qla2xxx_nacl, se_node_acl);
	kfree(nacl);
}

#ifdef SNMP_SUPPORT
u32 tcm_qla2xxx_tpg_get_inst_index(se_portal_group_t *se_tpg)
{
	return 1;
}
#endif /* SNMP_SUPPORT */

void tcm_qla2xxx_release_cmd(se_cmd_t *se_cmd)
{
	return;
}

int tcm_qla2xxx_shutdown_session(se_session_t *se_sess)
{
	return 0;
}

void tcm_qla2xxx_close_session(se_session_t *se_sess)
{
	return;
}

void tcm_qla2xxx_stop_session(se_session_t *se_sess, int sess_sleep , int conn_sleep)
{
	return;
}

void tcm_qla2xxx_reset_nexus(se_session_t *se_sess)
{
	return;
}

int tcm_qla2xxx_sess_logged_in(se_session_t *se_sess)
{
	return 0;
}

#ifdef SNMP_SUPPORT
u32 tcm_qla2xxx_sess_get_index(se_session_t *se_sess)
{
	return 0;
}
#endif /* SNMP_SUPPORT */

int tcm_qla2xxx_write_pending(se_cmd_t *se_cmd)
{
	return 0;
}

int tcm_qla2xxx_write_pending_status(se_cmd_t *se_cmd)
{
	return 0;
}

void tcm_qla2xxx_set_default_node_attrs(se_node_acl_t *nacl)
{
	return;
}

u32 tcm_qla2xxx_get_task_tag(se_cmd_t *se_cmd)
{
	return 0;
}

int tcm_qla2xxx_get_cmd_state(se_cmd_t *se_cmd)
{
	return 0;
}

void tcm_qla2xxx_new_cmd_failure(se_cmd_t *se_cmd)
{
	return;
}

int tcm_qla2xxx_queue_data_in(se_cmd_t *se_cmd)
{
	return 0;
}

int tcm_qla2xxx_queue_status(se_cmd_t *se_cmd)
{
	return 0;
}

int tcm_qla2xxx_queue_tm_rsp(se_cmd_t *se_cmd)
{
	return 0;
}

u16 tcm_qla2xxx_get_fabric_sense_len(void)
{
	return 0;
}

u16 tcm_qla2xxx_set_fabric_sense_len(se_cmd_t *se_cmd, u32 sense_length)
{
	return 0;
}

int tcm_qla2xxx_is_state_remove(se_cmd_t *se_cmd)
{
	return 0;
}

u64 tcm_qla2xxx_pack_lun(unsigned int lun)
{
	WARN_ON(lun >= 256);
	/* Caller wants this byte-swapped */
	return cpu_to_le64((lun & 0xff) << 8);
}
